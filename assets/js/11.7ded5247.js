(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{428:function(s,a,n){"use strict";n.r(a);var e=n(2),t=Object(e.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[a("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad771fdf93774e158cebf7da3fe22fca~tplv-k3u1fbpfcp-watermark.image?",alt:"微信图片_20210323172035.jpg"}})]),s._v(" "),a("p",[s._v("想知道如何实现一个简单的限制并发数量，首先我们需要知道以下几点")]),s._v(" "),a("h3",{attrs:{id:"js-如何执行并发请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-如何执行并发请求"}},[s._v("#")]),s._v(" JS 如何执行并发请求")]),s._v(" "),a("p",[s._v("如我们所知，JS 是单线程的，其工作原理是将每一个任务切分成多个片段然后交给 v8 引擎去快速交替按照顺序执行这些片段。")]),s._v(" "),a("p",[s._v("一般情况下，在单线程中，所有的任务队列是需要排队，前一个任务执行完毕才会执行下一个，但如果前一个任务执行的时间很长，后面的任务就一直被阻塞一直等待着吗？所以这个时候我们的 JS 异步就显得尤为重要了。")]),s._v(" "),a("p",[s._v("那么 JS 是如何实现异步请求的呢？或者说并发请求的? 答案就是消息队列和事件循环啦！！")]),s._v(" "),a("p",[s._v("这里可能又有人要问了，异步就是并发吗？那我们简单解释一下")]),s._v(" "),a("h5",{attrs:{id:"什么是异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是异步"}},[s._v("#")]),s._v(" 什么是异步？")]),s._v(" "),a("p",[s._v("所谓异步是指你不需要等待函数调用结果返回, 调用之后可以马上去做另外一件事")]),s._v(" "),a("h5",{attrs:{id:"什么是并发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是并发"}},[s._v("#")]),s._v(" 什么是并发？")]),s._v(" "),a("p",[s._v("并发是指有两个任务 A 和 B，在一段时间内，通过在任务间"),a("strong",[s._v("切换")]),s._v("来完成两个任务，这种情况叫并发。")]),s._v(" "),a("p",[s._v("即可以不同步地执行多个任务, 所谓同步就是执行完这件事, 再处理另外一件事")]),s._v(" "),a("p",[s._v("*****可见并发和异步某种程度上有相似的性质, 这是因为异步其实就是并发的一种方式***")]),s._v(" "),a("p",[s._v("那么我们再提一嘴和并发经常一起被问区别的并行")]),s._v(" "),a("h5",{attrs:{id:"什么是并行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是并行"}},[s._v("#")]),s._v(" 什么是并行")]),s._v(" "),a("p",[s._v("和并发不同的是并行是一个微观概念，假设我们的 CPU 有两个核心，那么我们就可以同时完成 A，B 两个任务。即可以在同一时间段"),a("strong",[s._v("同时")]),s._v("完成多个任务的情况可以称为并行")]),s._v(" "),a("p",[s._v("我们再来简单说说上面的提到的消息队列和事件循环，当然这次我们的重点不是他们，就一句话概括啦~")]),s._v(" "),a("h3",{attrs:{id:"消息队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[s._v("#")]),s._v(" 消息队列")]),s._v(" "),a("p",[s._v("我们知道队列是一个先进先出的结构，而这个队列里面存入的一般是我们上面提到的 JS 的任务")]),s._v(" "),a("h3",{attrs:{id:"事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[s._v("#")]),s._v(" 事件循环")]),s._v(" "),a("p",[s._v("主线程不断重复的从消息队列中取出消息执行，当消息队列为空时，就会等待消息队列中有消息的存在，而主线程只有将当前消息执行完毕后，才会去执行下一个消息。这个过程就叫做事件循环。")]),s._v(" "),a("h3",{attrs:{id:"代码实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码实现"}},[s._v("#")]),s._v(" 代码实现")]),s._v(" "),a("p",[s._v("了解了上面的概念之后，我们就要逐步用代码实现啦")]),s._v(" "),a("p",[s._v("我们首先选择用一个类来实现，那么既然是限制并发，那么构造函数里面必有得一个参数就是 limit 限制参数，其次我们需要一个队列，来存储我们获取到得任务，这个就定义一个数组来实现啦。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("class Scheduler {\n  constructor(limit) {\n    this.limit = limit;//限制并发数量\n    this.queue = [];//存储消息的消息队列\n  }\n  ……\n  }\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("想一想接下来该干什么，我们既然有了可以存储消息的消息队列了，我们是不是该实现一个消息存储的方法了?")]),s._v(" "),a("p",[s._v("我们借助定时器来帮我们模拟执行时间不同的异步请求，同时为确保我们的是执行完当前任务再执行下一个任务，我们这里需要借助 Promise 来帮我们来包裹一下异步请求，使我们的返回结果是一个 Promise 对象，可以调用 then")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("add(time, order) {\n     //模拟不同的异步请求任务\n    const foo = () => {\n      return new Promise((reslove, reject) => {\n        setTimeout(() => {\n          console.log(order);//注意！！order是为了帮我们查看执行完毕的是插入的第几个任务\n          reslove();\n        }, time);\n      });\n    };\n    //向队列中插入任务\n    this.queue.push(foo);\n  }\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("p",[s._v("有了任务队列和任务存储逻辑了，接下来就是事件循环做任务的拿取和执行啦，既然我们要限制并发的数量，那么 limit 这个参数肯定是要用到的，那么如何控制一次只获取 limit 个数量的任务呢？那最直接的方式就是循环啦！")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("  taskStart() {\n    for (let i = 0; i < this.limit; i++) {\n       ……\n    }\n  }\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("这个事件循环并不完整，让我们来思考两个问题")]),s._v(" "),a("ul",[a("li",[s._v("循环里面该做什么呢？我们一次循环了两个异步任务，但并未获取出来执行。")]),s._v(" "),a("li",[s._v("我们两个任务的执行时间完全不同，什么时候进行下一个任务的执行呢？当然是先执行完毕的那个异步任务先获取执行队列中下一个任务啊！")])]),s._v(" "),a("p",[s._v("显然这一套逻辑在 for 循环中实现是不可能的，我们需要另外封装一个请求函数，来帮助我们实行")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("  taskStart() {\n    for (let i = 0; i < this.limit; i++) {\n      this.request();//两次循环都去到执行任务的逻辑中\n    }\n  }\n    //请求队列中异步消息执行的函数\n  request() {\n    if (!this.queue.length) return;//如果消息队列中一个任务都没有了就返回\n    let item = this.queue.shift();//从头部拿取第一个任务，先进先出的原则\n    item().then(() => {//先执行完的任务，再调取任务队列中下一个任务\n      this.request();\n    });\n  }\n}\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("p",[s._v("至此，我们的 scheduler 类实现完毕了")]),s._v(" "),a("p",[s._v("接下来就是进行调试，创建实例化对象，调用里面的方法看看能不能行")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('let scheduler = new Scheduler(2);//创建一个实例化对象传入一个参数，限制一次执行2个任务\n//定义一个调用插入任务队列的函数，省去了反复写scheduler.add这么一大坨调用示例的麻烦\nconst addTask = (time, order) => {\n  scheduler.add(time, order);\n};\n\naddTask(1000, "1");//同等于scheduler.add(1000, "1");\naddTask(500, "2");\naddTask(300, "3");\naddTask(400, "4");\n\nscheduler.taskStart();\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("p",[s._v("看看结果：")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c62871418924a4e9c46cfd0cb1f4a9d~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),s._v(" "),a("p",[s._v("我们来算一算是否对的上\n我们先插入队列的是 order 为 1、2 的两个任务，当然就是这两个先执行")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v('       addTask(1000, "1")\n       addTask(500, "2");\n')])])]),a("p",[s._v("1 的执行时间为 1000 秒后，而 2 的执行时间为 500 毫秒，故先打印 2")]),s._v(" "),a("p",[s._v('2 执行完毕后立即去获取执行 3，addTask(300, "3")，3 在 300 毫秒后执行，500+300=800 还是小于 1 的 1000 毫秒，所以再打印 3')]),s._v(" "),a("p",[s._v('3 执行完毕立马又去获取执行任务 4，addTask(400, "4")，4 在 400 毫秒后执行，这个时候事件累加成了 500+300+400=1200 毫秒,1200 毫秒大于 1000 毫秒，所以 1 应该先执行完毕了，先打印 1，再打印 4，答案没错！我们成功啦！')]),s._v(" "),a("p",[s._v("以下附上完整代码")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('class Scheduler {\n  constructor(limit) {\n    this.limit = limit;\n    this.queue = [];\n  }\n\n  add(time, order) {\n    const foo = () => {\n      return new Promise((reslove, reject) => {\n        setTimeout(() => {\n          console.log(order);\n          reslove();\n        }, time);\n      });\n    };\n    this.queue.push(foo);\n  }\n\n  taskStart() {\n    for (let i = 0; i < this.limit; i++) {\n      this.request();\n    }\n  }\n\n  request() {\n    if (!this.queue.length) return;\n    let item = this.queue.shift();\n    item().then(() => {\n      this.request();\n    });\n  }\n}\n\nlet scheduler = new Scheduler(2);\n\nconst addTask = (time, order) => {\n  scheduler.add(time, order);\n};\n\naddTask(1000, "1");\naddTask(500, "2");\naddTask(300, "3");\naddTask(400, "4");\n\nscheduler.taskStart();\n\n// 2314\n\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br"),a("span",{staticClass:"line-number"},[s._v("42")]),a("br"),a("span",{staticClass:"line-number"},[s._v("43")]),a("br"),a("span",{staticClass:"line-number"},[s._v("44")]),a("br"),a("span",{staticClass:"line-number"},[s._v("45")]),a("br"),a("span",{staticClass:"line-number"},[s._v("46")]),a("br"),a("span",{staticClass:"line-number"},[s._v("47")]),a("br"),a("span",{staticClass:"line-number"},[s._v("48")]),a("br")])])])}),[],!1,null,null,null);a.default=t.exports}}]);