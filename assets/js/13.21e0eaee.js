(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{431:function(a,s,n){"use strict";n.r(s);var t=n(2),e=Object(t.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("p",[s("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd8efaf047d547b8b0592061f6c7a7e3~tplv-k3u1fbpfcp-watermark.image?",alt:"微信图片_20210323172151.jpg"}})]),a._v(" "),s("p",[a._v("通过上一篇文章我们知道了 this 的指向，以及 call、apply、bind 的作用，简单回顾一下")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('//定义一个对象，对象中挂载一些属性\nlet obj = {\n  name: "夹心啊",\n  age: 18,\n  type: "美女",\n};\n\nvar name = "Alice";\n\nfunction foo(num1, num2) {\n  console.log(this.name);\n  console.log(this.age);\n  console.log(this.type);\n  console.log(num1 + num2);\n}\n\nfoo.call(obj,1,2)\n\nfoo.apply(obj,[1,2])\n\nvar newFoo=foo.bind(obj)\nnewFoo(1,2)\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br")])]),s("p",[a._v("看看结果")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76a230a9155c44298fadb087815fc404~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),a._v(" "),s("p",[s("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4061437c20d74cddbdd2cff483288ea3~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),a._v(" "),s("p",[s("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c8469ef0bae4f9e9206aacee5179745~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),a._v(" "),s("h3",{attrs:{id:"call、apply、bind-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#call、apply、bind-的区别"}},[a._v("#")]),a._v(" call、apply、bind 的区别")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("执行方法：从上面可以看出 call 和 apply 都是使用后直接执行，但是唯独 bind 不会立即给你执行，而是返回一个新的函数，需要你去手动调用")])]),a._v(" "),s("li",[s("p",[a._v("传参方式：call 传参采用一个一个参数列举，apply 则采用数组传参方式，将使用的参数包裹在一个数组内。bind 有两种方式，你可以和 call 一样在调用 bind 的时候直接传参，也可以等 call 返回一个新函数后，调用新函数时向新函数内传参。")])])]),a._v(" "),s("h3",{attrs:{id:"call-实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#call-实现原理"}},[a._v("#")]),a._v(" call 实现原理")]),a._v(" "),s("p",[a._v("前期铺垫做完了，我们已然发现了 call、apply、bind 的作用和区别，那我们先来实现一下 call 吧")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("首先我们知道，我们的函数身上并没有 call、apply、bind 这三种方法，所以他们必定是挂载在"),s("strong",[a._v("函数原型")]),a._v("上的。"),s("em",[a._v("Function.prototype.myCall")])])]),a._v(" "),s("li",[s("p",[a._v("同时我们知道他们传进去的第一个必定是一个对象，剩下几个都是参数，但是我们并不知道它会传多少个参数，所以需要将参数做一个切割，将对象和其他参数分别切出来,没有传参数的情况也要考虑到"),s("strong",[a._v('var args = [...arguments].slice(1)||"";')])])]),a._v(" "),s("li",[s("p",[a._v("最重要的一点来了，实际上，我们为了能让 foo 中的 this 指向 obj，我们还是采用了"),s("strong",[a._v("隐式绑定规则")]),a._v("，即让 foo 挂载在 obj 内部，让 obj 进行调用！这就是 call 能改变 this 绑定的最终奥义！")])])]),a._v(" "),s("h3",{attrs:{id:"call-的代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#call-的代码"}},[a._v("#")]),a._v(" call 的代码")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("Function.prototype.myCall = function (context) {\n    //参数用slice切割，将对象后面传入的参数拿出来\n   var args = [...arguments].slice(1);\n   //注意必须将arguments结构一下，它是类数组，不解构无法使用数组身上的api哦\n   ……\n };\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("p",[a._v("接下来我们要思考了，也是最大的难题，我们要如何拿到 foo，让它挂载在 obj 上呢？仔细想想，我们上一篇文章里面讲到了什么？\nthis！！我们要使用 call 是不是需要用函数去调用？那么函数中的 this 自然会指向 foo 上下文咯！！所以 this 就相当于我们的 foo 函数了")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("//context是传入的obj\nFunction.prototype.myCall = function (context) {\n    //参数用slice切割，将obj拿出来\n   var args = [...arguments].slice(1);\n   //注意必须将arguments结构一下，它是类数组，不解构无法使用数组身上的api哦\n   context['fn'] = this;//this指向调用mycall的函数，将这个函数挂载到对象\n };\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("p",[a._v("到这一步，其实 call 的原理已经差不多了,但 call 还帮我们多做了一步，就是调用改变 this 指向后的函数，返回它的返回结果。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("Function.prototype.myCall = function (context) {\n  var args = [...arguments].slice(1); //参数用slice切割，将obj拿出来\n  context['fn'] = this;//this指向调用mycall的函数，将这个函数挂载到对象\n  const res = context['fn'](...args);//调用改变this指向后的函数\n  return res;//返回它的返回结果。\n};\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("p",[a._v("这样一个 call 方法基本就完成了，让我来试试好不好用")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d950b1c3096a455baf6ebe90a10c2565~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),a._v(" "),s("p",[a._v("Yes!!我们成功啦！！")]),a._v(" "),s("h3",{attrs:{id:"代码完善"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码完善"}},[a._v("#")]),a._v(" 代码完善")]),a._v(" "),s("ul",[s("li",[s("h4",{attrs:{id:"delete-删除-obj-上多出来的函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#delete-删除-obj-上多出来的函数"}},[a._v("#")]),a._v(" delete 删除 obj 上多出来的函数")])])]),a._v(" "),s("p",[a._v("但这样的代码并不完美，为什么呢？让我们来看看 obj 上多了点什么")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/089a65a787544404a95d6d78fc9aa455~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),a._v(" "),s("p",[a._v("你会看到，我们的 obj 上多了一个名叫 foo 的函数，是我们在 myCall 内部给 obj 挂载上去的，但是我们原本的 call 是不会这样的，所以我们还需要多做一步，就是在函数调用完毕后，将刚刚挂载到 obj 的函数删除\n"),s("strong",[a._v("delete context['fn']")])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("Function.prototype.myCall = function (context) {\n  var args = [...arguments].slice(1); //参数用slice切割，将obj拿出来\n  context['fn'] = this;//this指向调用mycall的函数，将这个函数挂载到对象\n  const res = context['fn'](...args);//调用改变this指向后的函数\n  delete context['fn']//将刚刚挂载到obj的函数删除\n  return res;//返回它的返回结果。\n};\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("ul",[s("li",[s("h4",{attrs:{id:"不传参会发生什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不传参会发生什么"}},[a._v("#")]),a._v(" 不传参会发生什么")])])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b79340274604217a0d499ca4ff550a9~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),a._v(" "),s("p",[a._v("我们发现不传参 this 就指回全局，但是我们的 myCall 并没有处理这一步，会报错")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e322071fce747718ed2355ebbcbd3cb~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),a._v(" "),s("p",[a._v("所以我们需要在使用传入 context（obj）前处理一下，如果没传入 obj 就让它指向 window\n"),s("strong",[a._v('var context = context || "window";')])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('Function.prototype.myCall = function (context) {\n  var context = context || "window";//如果没传入obj就让它指向window\n   ……\n};\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("ul",[s("li",[s("h4",{attrs:{id:"挂载一个独一无二的-fn"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#挂载一个独一无二的-fn"}},[a._v("#")]),a._v(' 挂载一个独一无二的"fn"')]),a._v("\n思考一下万一 obj 里面存在一个与 fn 重名了的函数怎么办呢，我们 myCall 应该去调用执行哪个呢？我们想一想 ES6 里面新增了一个什么数据类型可以帮我们解决这个问题？是不是 Symbol。可以声明一个不被改变的独一无二的 fn。"),s("strong",[a._v('const fn = Symbol("fn")')]),a._v('\n注意这样的话 context["fn"]里面的引号就要去掉了,因为此时的 fn 是声明的一个变量了，而不是一个名称。')])]),a._v(" "),s("p",[a._v("想到这三点处理，我们的没有 myCall 就完美做成了")]),a._v(" "),s("p",[a._v("以下是 myCall 完整代码")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('Function.prototype.myCall = function (context) {\n  var context = context || "window";\n  var args = [...arguments].slice(1)||"";\n  const fn = Symbol("fn");\n  context[fn] = this;\n  const res = context[fn](...args);\n  delete context[fn];\n  return res;\n};\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br")])]),s("p",[a._v("试一试效果")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f79ff490b93f4847b0bfceca366b9919~tplv-k3u1fbpfcp-watermark.image?",alt:"image.png"}})]),a._v(" "),s("p",[a._v("不错不错，真完美~~")])])}),[],!1,null,null,null);s.default=e.exports}}]);